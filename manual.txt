MANUAL: information.png	Introduction	<just:center><font:Palatino Linotype:26>Introduction<br><just:left><font:Palatino Linotype:18>Welcome to the VCE Handbook! My name is Duckster, and I'll be your guide.<br><br>First off, if you're new to the VCE, I suggest you start at the first beginner tab, and continue step by step until you reach the end. If you have prior experience, feel free to jump around in the handbook. If you reach a section where you don't know how to do something, you might be too far in.<br><br>For those who actually are about the time and effort that went into this mod, feel free to read the History and Credits sections.
MANUAL: information.png	History	<just:center><font:Palatino Linotype:26>History<br><just:left><font:Palatino Linotype:18>Since the beginning of Blockland, players have always wanted to design their own role-playing game, design advanced event contraptions, or even simple contraptions that would be impossible with the default selection of events. These desires is what fueled this mod into creation. Zack0Wack0 is the man for the job. He wished to create a mod the revolutionized the eventing world, and so he did. When events were first developed in Blockland, Zack0Wack0 teamed up with one of his scripting idols, Chrono. Chrono created the first version of the mod and sent it to Zack0Wack0. Zack0Wack0 then hosted the mod, and the crowd went wild.<br><br>Eventually, Chrono grew tired of working on the mod. Zack0Wack0 then carried the project on through the fourth version. Zack0Wack0 has tagged Truce along as a sidekick, and he created some extensions to the mod. After that, the mod remained unchanged, as the people of Blockland loved it as it was.<br><br>A while after Zack0Wack0's downtime, small talk had begun about a "Variable Replacers" system. Clockturn had messaged Zack0Wack0, and told him that he had a variable replacer system. This evolved into the fifth installment of the mod. The entire core of the mod was complete rewritten, optimized, and soon released among a few beta testers. Many people loved it, but some could not understand it. That is when this manual was born. The event mod continued to become more advanced with nifty features as new ideas tumbled into Zack0Wack0's hands.<br><br>I long time later, in the eleventh version of the mod, Zack0Wack0 summoned Boom to help out with the manual. Since the fifth version, he understood the mod very well, and has mastered every aspect of the mod. Because Boom can speak to the common people in lamens terms, he was put up to the task of rewriting the manual for better understanding. A lot of time has been put into this mod, and it has evolved greatly since its first version. Hopefully everyone will continue to enjoy it. Have fun!
MANUAL: information.png	Credits	<just:center><font:Palatino Linotype:26>Credits<br><just:left><font:Palatino Linotype:18> <li> Zack0Wack0: Creator; Documentation; Scripter; GUIs<br> <li> Clockturn: Scripter<br> <li> Chrono: Scripter<br> <li> Truce: Scripter; GUIs<br> <li> Lilboarder: Testing; Documentation<br> <li> Jaydee: Testing<br> <li> Boom: Manual Writer<br> <li> All of the awesome people who use this mod :3
MANUAL: 		
MANUAL: beginner.png	Beginner	<just:center><font:Palatino Linotype:26>Beginner<br><just:left><font:Palatino Linotype:18>Welcome to the first part of the VCE Handbook. Before you go in depth in the VCE and play around with variables, it would be a good idea to know exactly what a variable is.<br><br>A variable is simply something that changes. Its opposite, a constant, does not change. An example of a constant would be the symbol for Pi (3.141...). Pi never changes. A variable on the other hand, does. A good example of a variable is money. Let's say that you have $40. Therefore, we could have a variable called "Cash" and set it to 40. Now, let's say you buy an item for $10. You now have $30. How did you know that? You simply subtracted $10 from the original $40 to get $30. In the VCE, you would modified the "Cash" variable by subtracting 10 from it. Pretty simple, huh?<br><br>Now that you know the basic concept of variables, it's time to break down the formatting of the VCE. The biggest part of the VCE is the ability to use IF statements. An IF statement in the VCE looks like this: "onActivate -> Self -> VCE_ifVariable -> [Cash] >= [40] [ ]". In the VCE, certain things go in certain places. In the first box, you have the variable being compared. In the second box, you have what it is being compared to, and inbetween the two, you have two comparison symbols telling the VCE how it's being compared. You will learn about the last box in the section called "Multiple IF Statements". Until then, only use one IF statement per brick. For those who can't tell, ">=" means greater than or equal to. Here's what this IF statement is saying in english, "if "cash" is greater than or equal to 40, ...". This statement will either come back true or false.<br><br>By using the inputs that come with the VCE, you can make things happen based on whether or not the IF statement was true or false. For the IF statements, you will use onVariableTrue, for when the statement is true, and onVariableFalse, for when the statement is false. Before we continue, allow me to show you all of the comparison symbols and their meaning:<br><br>== : Equal to<br>!= : Not equal to<br>>= : Greater than or equal to<br><= : Less than or equal to<br>> : Greater than<br>< : Less than<br>~= : Similar or equal to<br><br>Now you know the basic format behind the VCE. I think you are ready to start making your own variables!
MANUAL: 		
MANUAL: bullet_arrow_down.pn	Variables	<just:center><font:Palatino Linotype:26>Variables<br><just:left><font:Palatino Linotype:18>Welcome to the Variable section in the VCE Handbook. Before you continue reading this section, be sure that you understand the concept of a variable. In the VCE, you can make your own variables. These variables can be used for keep track of money, stats, scores, you name it. To make a variable, you can simply use the VCE_modVariable output event. Here's what that will look like: "onActivate -> Self -> VCE_modVariable {Brick} -> [Cash] add [1]". As you can see, there are four parameters in this event. There's the target of where the variable is located, the variable you are modifying, how you are modifying it, and by how much you are modifying it. In the example, I am adding "1" to the variable "Cash". The "Cash" variable is on the "Brick" target. There are many ways to modify a variable some of options only require one value on the second box while some require none. In some cases though they will require multiple values, in order to use these you must seperate each value by a ",". Here's a list of them, and what they do:<br><br>Set : Sets the variable to the specified number<br>Add : Adds the specified number to the variable<br>Subtract : Subtracts the specified number from the variable<br>Multiply : Multiplies the variable by the specified number<br>Divide : Divides the variable by the specified number<br>Modulos : Performs a modulos function by the value specified<br>Power : Puts the variable to the power of the value specified<br>Radical : Takes the root by the value specified<br>Percent : Takes the specified number, divides it by the variable, and converts to percent.<br>random : Sets the variable as the minimum, the specified number as the maximum, and randomly picks an integer between.<br>Floor : Rounds the variable down. Specified number unused.<br>Ceil : Rounds the variable up. Specified number unused.<br>Clamp : If the variable is below the first value or above the second value the variable will be set to that value.  Must input two values.<br>Sin : Performs a sine function on the variable. Specified number unused.<br>Cos : Performs a cosine function on the variable. Specified number unused.<br>Tan : Performs a tangent function on the variable. Specified number unused.<br>ASin : Performs an inverse sine function on the variable. Specified number unused.<br>ACos : Performs an inverse cosine function on the variable. Specified number unused.<br>ATan : Performs an inverse tangent function on the variable. Specified number unused.<br>Length : Sets the variables to the length of the variable's string. Specified value unused.<br>stringPosition : Sets the variable to the position of the first occurance of the value.<br>Lowercase : Makes all characters in the variable lowercase. Specified number unused.<br>Uppercase : Makes all characters in the variable uppercase. Specified number unused.<br>Character : Finds all characters and symbols that proceed the specified number/character.<br>Replace : Replaces all occurances of the first value with the second value. Must input two values.<br>Trim : Removes all spaces before and after the variables. Specified number unused.<br>SubString : Sets the variable to only a section of it where the first value is the index of the first character and the second is how many characters after that. Must input two values.<br>words : Finds the Nth word in the variable. N is set to the specified number.<br>CountWord : Sets the variable to the number of words in the variable.<br>SubWord : Sets the variable to a section of words specified by the first value which is the index of the first word and the second which is the index of the ending word. Must input two values.<br>RemoveWord : Sets the variable to the string with the word at the value's index removed.<br>RemoveWords : Sets the variable to the string with a section of the words removed specified by the first value which is the first word and the second value which is the ending word. Must input two values.<br>SetWord : Sets the variable to the string but with the word at the first value's index set to the second value. Must use two inputs.<br>And : Sets the variable to true if both the variable and value are true.<br>Or : Sets the variable to true if either the variable or the value are true.<br>BitwiseAnd : Performs the Bitwise function between the variable and the value.<br>BitwiseOr : Performs the Bitwise function between the variable and the value.<br>BitwiseShiftRight : Performs the Bitwise function between the variable and the value.<br>BitwiseShiftLeft : Performs the Bitwise function between the variable and the value.<br>BitwiseXOR : Performs the Bitwise function between the variable and the value.<br>BitwiseComplement : Performs the Bitwise function between the variable and the value. Specified number unused.<br>LogicalInverse : Inverts the variable. Specified number unused.<br><br>As you can see, there are many ways to modify a variable. Now that you know how to modify a variable, it's time for you to learn about variable replacers. The fancy term "Variable Replacer" simply means a word that replaces the variable in such a way that the VCE can interpret it. Variable replacers can be used in evented prints, specified numbers in modification, and IF statements. If you have not learned IF statements, please go back and read the previous section.<br><br>Now, a variable replacer works in three parts. You have the term "var", which simply specifies that the string is a variable. Next, you have the target. The target can range anywhere from the brick, player, client, vehicle, or minigame. There is also global variables which can only be used in variable replacers, and also a Named Brick target feature. You simply use "nb_(brick name)" as the target.<br><br>Lastly, you have the name of the variable. Each section is seperated by a colon. The string starts with a "<", and ends with a ">". Let's use the example, "Cash". I know that "Cash" was set to the brick target. Therefore, my variable replacer will look like this: <var:brick:cash>. Variable replacers are not case-sensitive. Also, you can substitute the target of the variable replacer like so: "br" for brick, "pl" for player, "cl" for client, "ve" for vehicle, "mg" for minigame, and "gl" for global. It's very simple.
MANUAL: bullet_arrow_down.pn	Values	<just:center><font:Palatino Linotype:26>Values<br><just:left><font:Palatino Linotype:18>Welcome to the Value section in the VCE Handbook. Values are very similiar to variables. In fact, they are variables, but values are special variables. When using the output VCE_ifValue, you will see a setup very similar to VCE_ifVariable. Instead of using the name of the variable in the first box, you can only use variable replacers. If you do not know what variable replacers are, please read the previous section.<br><br>So, what makes a variable special? Simple. A special variable, or value, is simply a variable that you cannot modify. For example, there is a value that checks if the player is an admin. It's a good variable to have, but you don't want people modifying it to become an admin. Therefore, it is a value. Here's some of the client variables to give you an idea of how they work:<br><br><var:client:brickCount> : The client's brickcount<br><var:client:BL_ID> : The client's BLID<br><var:client:name> : The client's name<br><br>As you can see, there is a very short list of values that can be used. The targets of values may be shortened too. You are not limited to just using values in VCE_ifValue. Any variable replacer will work. If you want to see a full list of varaibles on a server type /SVD, which stands for Special Variable Dictionary. Now that you know all of the values, why not go try some out?
MANUAL: bullet_arrow_down.pn	Saving/Loading	<just:center><font:Palatino Linotype:26>Saving/Loading<br><just:left><font:Palatino Linotype:18>Welcome to the Saving and Loading Variables section in the VCE Handbook. Saving and Loading variables is probably the easiest part of the VCE. Since you should understand variables very well by now, this section will go quickly for you.<br><br>First off, you can only save player and client variables. Good news is, you can reload them later. This means that if a user leaves the servers and looses his player and client tied variables, he or she can reload them through the VCE as long as the server has been up while they were gone.<br><br>To save variables, you use the VCE_saveVariable command on the Self target. To load variables, you use the VCE_loadVariable command that is also on the self target. The layout is pretty straight forward, so you should not get lost. Just simply type in the name of the variable you wish to save or load. To load more than one, you can do this: "Var1, Var2, Var3, Var4". See how each variable is followed by a comma and a space? If you're trying to load a lot of variables, spaces can add to the character count, disallowing you to keep adding variables that you want to save or load. You can actually just use commas to seperate the variables like so: "Var1,Var2,Var3,Var4". Be warned, if you start using one format of seperation, do not switch. This would be incorrect: "Var1, Var2, Var3,Var4" See how there is no space between Var3 and Var4? That needs to be changed or the variables will not load correctly. Now that you can save and load your variables, the limits of the VCE just improved.
MANUAL: bullet_arrow_down.pn	Retro Check	<just:center><font:Palatino Linotype:26>Retro Check<br><just:left><font:Palatino Linotype:18>Welcome to the Retro Check section in the VCE Handbook. As advanced as Retro Check may seem, I can assure you, it is not. It is placed after the Values section because I wanted you to learn the new way of using values rather than this. Retro Check is simply for the users of the VCE who liked the old way of checking variables better. Here's a list of Retro Check options, and what they relate to:<br><br>ifPlayerName : The player's name (<var:cl:name>)<br>ifPlayerID : The player's ID (<var:cl:BL_ID>)<br>ifAdmin : If the player is any kind of admin (Boolean) (<var:cl:isAdmin>)<br>ifPlayerEnergy : The amount of energy the player has (<var:pl:energy>)<br>ifPlayerDamage : The player's damage (<var:pl:damage>)<br>ifPlayerScore : The player's score<br>ifLastPlayerMsg : The last message from the player (<var:cl:lastmsg>)<br>ifBrickName : The name of the brick (<var:br:name>)<br>ifRandomDice : A random number between 1 and 6<br><br>VCE_retroCheck works just like any other value, it can't be changed through the VCE, however, it can't be displayed in an evented print unless you use its variable replacer correspondant. This concludes the Retro Check section of the VCE handbook.
MANUAL: 		
MANUAL: advanced.png	Advanced	<just:center><font:Palatino Linotype:26>Advanced<br><just:left><font:Palatino Linotype:18>Welcome to the Advanced section in the VCE Handbook. The following chapters discuss slightly more advanced features of the VCE. I recommend getting used to the basics beforehand. If you feel lost, that's okay, it just means that you are not yet ready for the advanced portion of the VCE.
MANUAL: 		
MANUAL: bullet_arrow_down.pn	Multiple IF Statements	<just:center><font:Palatino Linotype:26>Multiple IF Statements<br><just:left><font:Palatino Linotype:18>Welcome to the Multiple IF Statements section in the VCE Handbook. In the VCE, having multiple IF statements is really easy. Remember the last box on the VCE_ifVariable output? That can be used for multiple IF statements. Before we dive into using more than one IF statement, you need to know what that box does. Let's say you want two IF statements on one brick. Well, you can't go about doing this, because one IF statement executes all of the onVariableTrue/False events. With the last box on the right, you can control which events are executed. Let's say your first IF statement corresponds to the three events following it. The number of those events (which can be found on the far left) just happen to be events 3, 4, and 5. If you also had onVariableTrue/False events, they would be triggered too. But, if you type in "3 5" in the rightmost box, that IF statement will only check for onVariableTrue/False events with numbers 3 through 5. Simple, right? Using the last textbox will allow you to have multiple IF statements. As you can see, using multiple IF statements on one brick is really easy. Just for your information, events without an onVariableTrue/False input will not be run through an IF statement. They will simply run through their normal inputs. Another feature that can be used is in the first box of an if statement. You are able to use the characters "&" and "|" as logical operators. Let's go back to the orriginal if statement example but instead say we want to check if the player also has enough style points to buy this item (where the required ammount is also 40 or higher). We can simpely do this with the "&" operator like this: "onActivate -> Self -> VCE_ifVariable -> [Cash & stylePoints] >= [40] [ ]". In this example we have the and operator between the variables Cash and stylePoints seperated by spaces. This will now check if your cash and style points are greater or equal to 40. But what if we want the VCE_ifVaraible to return true if either are greater than fourty? Well it's simple use the "|" operator instead!  "onActivate -> Self -> VCE_ifVariable -> [Cash | stylePoints] >= [40] [ ]". Now either cash or stylePoints have to be 40 or higher to get a true out of the if statement. These operators can be used multiple times within an if statement on different variables so go crazy. Now that you know how to use multiple IF statements and logical operators, go try them out!
MANUAL: bullet_arrow_down.pn	Functions	<just:center><font:Palatino Linotype:26>Functions<br><just:left><font:Palatino Linotype:18>Welcome to the Functions section in the VCE Handbook. Functions are probably the most complex feature in the VCE. Functions come in three parts: calling functions within a brick, calling a function from another brick, and stating arguments while calling a function from another brick. Obviously, we'll start off at square one. The only required knowledge you need to know outside of the VCE for this is Relays. Relays are basically a way of controlling inputs and outputs. If you do not understand the concept of relays, I suggest you learn it.<br><br>Now, onto part one: calling functions within a brick. So, what's a function? It is quite similar to a relay. Functions, however, have names, meaning more than one per brick can be used. Before you can call a function, you must state that function or set up a startFunction inside for the brick. For stating the function you do so with the VCE_startFunction output on the Self target. VCE_startFunction has a dropdown and two boxes; A large one, and a small one. For now set the dropdown meny to Brick, this component will be explained in more detail later. The first box is where you put the name of the function. The second box is where you specify which onVariableFunction input events belong to that function. When using VCE_startFunction the input event doesn't matter as it will be declared when you leave the eventing window. Let's say you've stated the function "Check". You can now call that function with the VCE_callFunction output which is located under the Self target. VCE_callFunction comes with three boxes, this time all of them are large and of equal size. The first box is where you put the name of the function you wish to call. If you put "Check" in the first box, you'll call the function "Check" on the desired input. The second box is where you put the function's arguments. So, let's use the function "Check". Except this time, you will use the Named Brick target instead of the Self target. You will "on(Input) -> <NAMED BRICK> {Test} -> VCE_callFunction -> [Check] [   ] [   ]. This alone will call the function "Check" on all bricks named "Test". Let's use a basic variable replacer, <var:client:name>. If you put "<var:client:name>" into the second box, an argument will be created. The number of arguments starts at 0, and increments by 1. Since "<var:client:name>" is the only thing in the box, it becomes Argument0, or "arg0". Arguments can be displayed with a variable replacer like so: <var:brick:arg0>. Now, "<var:client:name>" is in that second text box which is a VCE_callFunction event with the named brick "Test" as the target. Because "Test" is the target, <var:brick:arg0> applies to all bricks with the name of "Test". Therefore, because "<var:client:name>" is the first argument (arg0), <var:brick:arg0> is the same as <var:client:name>. More than just values may be used as arguments. Custom variables, constants, and characters all work too. This can be handy if you need to transfer the variables from one brick to another. You can have more than one argument in a VCE_callFunction event. Each argument can be seperated by an absolute value sign " | ". So, let's say we have the variables "Gold", "Silver" and "Bronze" on an unnamed brick. You need those variables to be transfered to a brick named "Elements". All you need is to create and function, and the call that function through the Named Brick target. The second box will contain the three variables that we are turning into arguments. They are as followed: "<var:brick:gold> | <var:brick:silver> | <var:brick:bronze>". The variable "Gold" from the unnamed brick will become "arg0" on the brick named Elements. "Silver" will be "arg1", and "Bronze" will be "arg2". You may have as many arguments as you can fit into the text box. The third box is much more simple, it decides the delay before your function is actually called on your target brick. This may seem redundant as you can already delay events, but this third box also excepts replacers allowing you to set the delay to whatever you want according to you replacers. For example, lets say we want to delay our previous function call by our brick variable delay: on(Input) -> <NAMED BRICK> {Elements} -> VCE_callFunction -> [Check] [<var:brick:gold> | <var:brick:silver> | <var:brick:bronze>] [<var:br:delay>]. Great now whenever we call our function it will be delayed by whatever the brick variable delay is set too. However we may want to have a goblin randomly steal our elements. So how do we stop this function call from reaching the brick "Elements"?. Well because we delayed our function call we are able to use the VCE_CancelFunction Event. VCE_CancelFunction only has one large text box. This text box is where you will put the function's name you want to cancel. For example, we want to cancel the function "Check" being called to the Brick "Elements". This means we need to call VCE_CancelFunction on the brick "Elements": on(Input) -> <NAMED BRICK> {Elements} -> VCE_cancelFunction -> [Check]. And look at that, whenever we activate this event our function won't be successfuly called. One happy goblin. Now that you've learned how to use functions, it's time to move on to Next Section of the VCE Handbook.
MANUAL: bullet_arrow_down.pn	VarLinks	<just:center><font:Palatino Linotype:26>VarLinks<br><just:left><font:Palatino Linotype:18>Welcome to the VarLinks section in the VCE Handbook. Variable Links come in two parts. The actual link, and what it does, along with the input of onVariableUpdate. First off, variable links are only to be used the chat message events. When used, they will simply create a link, and when you click that link, a defined client variable will be set to a defined number.<br><br>Allow me to break it down. Like variable replacers, a variable link starts with a "<" sign, and ends with a ">" sign. With variable links, there are four parts. The first part is the phrase "varlink", which classifies this as a variable link. Seperated by a colon, the second part is the link name. For example, if I put "Click Here", the link would show as "Click Here". Simple concept. Now, the third section is seperated by an underscore, rather than a colon. After the underscore, you classify the name of the client variable you wish to use. Finally, the fourth section is seperated by another colon, and you type the value that you wish the defined client variable to be.<br><br>The big picture looks like this "<varlink:link name_variable:value>. So, <varlink:Click Here_clicked:1> in a chat message event would show up as "Click Here", and when you clicked that link, the client variable "clicked" (<var:client:clicked>) would be set to the value of 1. So, how would you make something happen at the same time as someone clicking a link? Simple. Use onVariableUpdate. The input of onVariableUpdate is triggered when a variable is changed, whether it is by a variable link, or by using VCE_modVariable. In the example variable link, I could use the event "onVariableUpdate -> Client -> VCE_ifVariable -> [Clicked] == [1] [ ]" to see if someone clicked the link. Variable links have multiple uses. Now that you know how to use variable links, go put it to good use!
MANUAL: bullet_arrow_down.pn	Other Replacers	<just:center><font:Palatino Linotype:26>Other Replacers<br><just:left><font:Palatino Linotype:18>Welcome to the Other Replacers section in the VCE Handbook. Here we will talk about function replacers and expression replacers.<br><br>Expression replacers let you do mathmatical expressions with only one text box. For variable replacers you would use the keyword "var" for variable but for expressions it's "e" for expression. Let's look at a previous example and show how expressions can be used. Previously we used this to add one to our variable cash "onActivate -> Self -> VCE_modVariable{Brick} -> [Cash] add [1]". But this can be done in another way using an expression: "onActivate -> Self -> VCE_modVariable{Brick} -> [Cash] set [<e:<var:br:cash> + 1>]". Let's break this down. First our outer expression, the "<e:" part, it incases the rest of the text there "<var:br:cash> + 1". When anything is inside an expression it will allow you to do mathmatical operations to it. In this example we're adding the value of <var:br:cash> by 1. Now that you have a basic idea of how expressions work let's lay down the ground rules so you don't run into any problems. First everything must have a space between it. It must be 1 + 1 not 1+1. Second only things inside of the expression will be calculated. This means that you can have 1 + 1 = <e:1 + 1> without the expression messing anything up. Here are some operators you can use in an expression grouped from highest precedence to lowest:<br><br>* : Multiplication, / : Division, % : Modulos<br>+ : Addition, - : Subtraction<br>BSR : Bit Shift Right, BSL : Bit Shift Left<br>gT : Greater Than, lT : Less Than, gT= : Greater Than Or Equal To, lT= : Less Than Or Equal To<br>== : Equal To, != : Not Equal To<br>& : Bitwise And<br>^ : Bitwise XOr<br>| : Bitwise Or<br><br>You may have noticed that not all of the mod variable functions are here. This is what variable functions are for, they take care of ones that can't use the expressions system. The keyword func denotes a function and semicolons seperate the other parts of the function call. The first part after the keyword is the function name. All names have a shorthand version and a normal version where the normal version is just the modVariable name. The second part is the inputs seperated by commas. For example using the power function would be <func:power:2,2> which could be read as 2 to the power of 2 which is equal to 4. Another example would be using words <func:words:1 2 3 4, 2> would results in 3 as it is the word at index 2. There are many more functions and they can be looked up in the manual in variables. Functions included in expressions are not included as a function replacer too.
MANUAL: bullet_arrow_down.pn	Advanced Functions	<just:center><font:Palatino Linotype:26>Welcome to the Advanced Functions section in the VCE Handbook. This section will be building on what we previously learned in the Functions section. Previously we talked about how VCE_StartFunction had a dropdown box. This box has two options "Brick" and "Local". These options refer to what kind of scope you want you function to be in. Meaning if your function has it's dropdown set to "Brick" only this brick or bricks that used a named brick target towards this brick can use this function. While if your function has it's dropdwon set to "Local" any brick can call this function without need to set it's target to the brick that owns the function. For example, lets state a local function named "Test" in an unnamed brick somewhere: onActivate -> Self -> VCE_startFunction -> {Local} [Test]. If we where to activate these events in a different brick: onActivate -> Self -> VCE_callFunction -> [Test] [   ] [   ]. Our function "Test" in the orriginal brick will be called even though our other brick has no references towards it. This is because we declared our function "Test" as "Local". However, if the brick that is calling the local funciton "Test" also has these events: onActivate -> Self -> VCE_startFunction -> {Brick} [Test]. The CallFunction will only call the function "Test" with the "Brick" scope. This is because CallFunction only calls Functions within "Brick" scope if they exist and then otherwise call "Local" scope functions.<br><br>Now onto more complicated function capabilities. There are special function names within function scope called Event Functions. These functions only get called when something specific happens like a player death and so on. A list of Event Functions can be found in /EFD. To use an event function you state a function with that Event Function's name on "Local" scope: onActivate -> Self -> VCE_startFunction -> {Local} [onPlayerDeath] [   ]. In this case I'm using onPlayerDeath which will get called whenver a player dies. If we wanted to send a chat message to a player when they died we would use that function statement and then add these events on: onVariableFunction -> Client -> ChatMessage -> [You Died]. Now Whenever someone dies they will recieve the chat message "You Died". Try it. Variable replacers also work: onVariableFunction -> Client -> ChatMessage -> [<var:pl:pos>]. Now whenever somone dies the position the player died at will be chat messaged to them. There is a lot you can do with Event Functions that previously wasn't possible so experiment.